// ESSA APLICAÃ‡ÃƒO TEM COMO OBJETIVO ESTUDO E APRENDIZADO //

ğŸ§  Como pensar e estruturar APIs escalÃ¡veis em Node.js
ğŸ”¹ 1. Comece pelo problema: â€œO que essa API precisa fazer?â€
Neste caso:

Consumir a PokÃ©API

Criar endpoints prÃ³prios (ex: /pokemon/:name)

Retornar dados filtrados em JSON

ğŸ§  RaciocÃ­nio:
â€œEu nÃ£o vou salvar nem alterar nada. SÃ³ buscar dados externos e entregar formatado.â€



ğŸ”¹ 2. Use arquitetura em camadas
Essa separaÃ§Ã£o facilita organizaÃ§Ã£o, testes e manutenÃ§Ã£o.

Pasta	        FunÃ§Ã£o
routes/	        Define os caminhos da API (ex: GET /pokemon/:name)
2- controllers/	Recebem a requisiÃ§Ã£o e enviam a resposta
1- services/	    Executam a lÃ³gica de negÃ³cio (ex: chamar API externa, tratar resposta)
models/	        Representam a estrutura dos dados usados na app
middlewares/	Tratam validaÃ§Ãµes, erros, autenticaÃ§Ã£o, etc.

src/app.js	    Monta o Express com rotas e middlewares
index.js	    Ponto de entrada, apenas inicializa o app e escuta a porta



ğŸ”¹ 3. Ponto de entrada: index.js
Ele faz trÃªs coisas:

Carrega .env com dotenv

Importa o app jÃ¡ montado da pasta src/

Sobe o servidor e escuta na porta

ğŸ§  RaciocÃ­nio:
â€œIndex.js Ã© sÃ³ o arranque. Tudo que for estrutura de app fica separado em src/.â€



ğŸ”¹ 4. Arquivo src/app.js
Aqui vocÃª:

Cria o Express

Define a rota raiz (/)

Usa suas rotas personalizadas (ex: /pokemon)

Usa o middleware de erro no final

ğŸ§  RaciocÃ­nio:
â€œO app.js Ã© o cÃ©rebro que monta as peÃ§as da aplicaÃ§Ã£o.â€



ğŸ”¹ 5. Roteamento: routes/pokemon.routes.js
Define rotas especÃ­ficas, como GET /pokemon/:name

Conecta a rota ao controller correspondente

ğŸ§  RaciocÃ­nio:
â€œCada rota sabe quem chama (controller), mas nÃ£o como processar â€” isso Ã© trabalho do controller e service.â€



ğŸ”¹ 6. Controlador: controllers/pokemon.controller.js
Recebe parÃ¢metros da URL (como :name)

Chama o service correspondente

Envia a resposta para o cliente

Captura erros com try/catch e passa pro middleware de erro

ğŸ§  RaciocÃ­nio:
â€œO controller Ã© o intermediÃ¡rio entre a requisiÃ§Ã£o e a lÃ³gica de negÃ³cio.â€



ğŸ”¹ 7. LÃ³gica de negÃ³cio: services/pokemon.service.js
Aqui acontece a requisiÃ§Ã£o Ã  PokÃ©API (fetch)

Se der erro, lanÃ§a uma Error

Se der certo, filtra os dados (sÃ³ envia o que interessa)

ğŸ§  RaciocÃ­nio:
â€œToda lÃ³gica pesada ou externa vai para os services. O controller sÃ³ chama e devolve.â€



ğŸ”¹ 8. Estrutura de dados: models/pokemon.model.js
Mesmo sem banco de dados, Ã© Ãºtil definir a estrutura esperada dos dados que vocÃª estÃ¡ manipulando.

ğŸ§  RaciocÃ­nio:
â€œMesmo sem persistÃªncia, modelos ajudam a manter consistÃªncia e clareza.â€



ğŸ”¹ 9. Tratamento de erro: middlewares/errorHandler.middleware.js
Recebe qualquer erro lanÃ§ado em controller ou service

Loga no console

Retorna status 404 ou mensagem genÃ©rica

ğŸ§  RaciocÃ­nio:
â€œNÃ£o quero try/catch em todos os lugares. Melhor centralizar o tratamento de erro aqui.â€



ğŸ§  Como raciocinar em futuros projetos?
âœ… Passo a passo mental:
Qual Ã© o objetivo da API?

Ex: buscar clima, cadastrar usuÃ¡rios, consultar produtos

Quais sÃ£o as rotas/endpoints?

Ex: GET /weather/:city, POST /user

O que cada rota precisa fazer?

Consultar API externa? Salvar no banco? Validar entrada?

Organize em camadas

Rota â†’ Controller â†’ Service â†’ (opcional: Model ou DB)

Trate erros de forma centralizada

Use um middleware final no app.js